{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Web3 Wiki","text":"<p>Welcome to our <code>Web3 Wiki</code>, the encyclopedia for web3 enthusiasts. </p> <p>Here you will find a wealth of knowledge on this emerging technology, including its core principles, use cases, and latest developments. </p>"},{"location":"#architecture","title":"Architecture","text":"<ul> <li>Blockchain Technology</li> <li>DApp</li> <li>Smart Contracts</li> <li>Zero Knowledge </li> <li>Multi-Party Computation</li> <li>DeFi</li> </ul>"},{"location":"#target-readers","title":"Target Readers","text":"<ul> <li>Blockchain Researchers</li> <li>Web3 Developers</li> <li>DeFi Investors</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>ZKP Mooc</li> <li>DeFi Mooc</li> <li>UIUC Blockchain Course</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Xingjian Fang</li> </ul>"},{"location":"Blockchain/Crypto/","title":"Cryptographic Premitives","text":"<p>A hash function is a mathematical function that maps input data of arbitrary size to a fixed-size output called a hash value:</p> <p>\\(H(x) :\\{ 0,1 \\}^{*} \\rightarrow \\{ 0,1 \\}^{l}\\)</p> <p>In recent years, cryptographic hash functions are widely used in the area of blockchain technology. Then we will introduce the definition and properties of cryptographic hash functions, as well as their usages.</p>"},{"location":"Blockchain/Crypto/#hash-functions","title":"Hash Functions","text":"<p>A hash function is a function that takes input data of arbitrary size and outputs a fixed-size hash value. It's a one-way function that generates the same output for the same input every time. </p> <p>Hash functions are commonly used in computer science for data indexing and searching, particularly in hash tables. A hash table is a key-value store where the value can be of any data type. The hash function maps each key to a unique index in an array, allowing for fast access to the value associated with a particular key.</p> <p></p> <p>A good hash function should have following properties:</p> <ul> <li>Arbitrary sized inputs</li> <li>Fixed size deterministic output</li> <li>Efficiently computable</li> <li>Minimize collisions </li> </ul> <p>SHA-256 is an example of a hash function that outputs a 256-bit hash value. While SHA-256 does not have provable security, it is used in the random oracle model, which assumes an arbitrary random k-bit string for any input with a uniform distribution.</p>"},{"location":"Blockchain/Crypto/#cryptographic-hash-functions","title":"Cryptographic Hash Functions","text":"<p>Cryptographic hash functions have additional properties that easy to compute but difficult to invert. The only way to find the input is through brute force search. </p> <p>The Merkle-Damgard construction is a widely used technique to construct a cryptographic hash function. The construction uses a compression function recursively to create a hash function that can take input data of any size.</p> <p>Cryptographic hash functions have various applications, including digital commitment, hash pointers, and hash puzzles\uff1a</p> <ul> <li>A commitment is a sealed envelope that contains a message that cannot be changed once committed. </li> <li>A hash pointer is a pointer to the value stored in the hash table. </li> <li>Hash puzzles are used to find inputs that produce a hash value less than a certain threshold. The input to the hash puzzle is called a nonce, and it is hard to compute but easy to verify.</li> </ul>"},{"location":"Blockchain/Crypto/#blockchain-technology","title":"Blockchain Technology","text":"<p>A blockchain is a linked list data structure that uses hash pointers to connect blocks of data. A block in a blockchain consists of a header and data. The header contains the hash value of the previous block, a timestamp, and other metadata. The hash value of the previous block connects the current block to the previous block, forming a chain of blocks. The sequence of ancestors of blocks is tamper-proof, making blockchains ideal for secure data storage.</p>"},{"location":"Blockchain/Crypto/#merkle-trees","title":"Merkle Trees","text":"<p>A Merkle tree is a binary tree where each parent node consists of the hash pointers to its children. Merkle trees are used in blockchain technology to allow for efficient verification of data. Instead of storing all the data in each block, the Merkle tree only stores the root hash value. Verifying the integrity of a block's data involves checking the hash value of each leaf node in the Merkle tree and comparing it to the root hash value.</p> <p></p>"},{"location":"Blockchain/Crypto/#block-as-a-ledger-and-digital-signature","title":"Block as a Ledger and Digital Signature","text":"<p>A block in a blockchain can be seen as a ledger that records an ordered list of data values. Digital signatures can be used to ensure the integrity of the data in a block. </p> <p>Digital signatures are generated using a secret key \\(sk\\) and can be verified using the corresponding public key \\(pk\\). The public key becomes the user's identity in the system. The Elliptic Curve Digital Signature Algorithm (ECDSA) is a widely used scheme for generating digital signatures in blockchain technology.</p>"},{"location":"Blockchain/Crypto/#conclusion","title":"Conclusion","text":"<p>Cryptographic hash functions are expected to be efficiently computable and collision resistant. They can be used to construct blockchains and Merkle trees, which are tamper-proof data structures. </p> <p>Digital signatures parallel hand-written signatures and thereby provide authenticated communication. All messages that are exchanged in a blockchain system are signed. Blockchain can maintain a centralized ledger, with a central authority writing to the ledger and multiple parties reading from it. </p>"},{"location":"Blockchain/Intro/","title":"Brief Introduction to Blockchain","text":""},{"location":"Blockchain/Intro/#definition","title":"Definition","text":"<p>Blockchains are a technology that underlie decentralized trust systems\uff1a</p> <ul> <li>Decentralization means that there is no central party or authority that controls the system. Instead, it operates as a peer-to-peer network, where all nodes in the network have equal control and access to the data. </li> <li>Trust is a critical component of any cooperative mechanism. In institutional trust, people trust the organization or government that backs the currency, such as the US dollar. </li> <li>In contrast, decentralized trust relies on the honest majority assumption, meaning that the majority of nodes in the network will act honestly and not attempt to manipulate the system.</li> </ul> <p></p>"},{"location":"Blockchain/Intro/#history","title":"History","text":"<p>The origins of blockchain technology can be traced back to the creation of Bitcoin in 2008. Bitcoin is a decentralized digital currency that utilizes a blockchain to keep track of transactions. One of the significant advantages of blockchain technology is its strong security properties. Because of the honest majority assumption, a blockchain is resistant to attacks and manipulation by a single actor. </p> <p>However, concerns about scalability have also been raised, as the number of transactions that can be processed on a blockchain is limited by its design.</p> <p></p>"},{"location":"Blockchain/Intro/#research-paradigm","title":"Research Paradigm","text":"<p>The process of developing blockchain technology involves several stages:</p> <ul> <li>The first step is to design systems that meet specific requirements, such as security, scalability, and decentralization. </li> <li>These systems are then analyzed theoretically to ensure that they meet their design goals. </li> <li>Once the theoretical analysis is complete, the systems are built in practice, and their implementation is tested to ensure that they function as intended.</li> </ul>"},{"location":"Blockchain/Intro/#conclusion","title":"Conclusion","text":"<p>In conclusion, blockchain technology is a powerful tool for creating decentralized trust systems. By eliminating the need for a central authority, blockchain technology enables secure, transparent, and efficient transactions. </p> <p>The process of developing blockchain technology involves careful design, theoretical analysis, practical implementation, and testing, all of which are essential for ensuring the system's effectiveness and security.</p>"},{"location":"Blockchain/PoW/","title":"PoW and Nakamoto Consensus","text":""},{"location":"DeFin/Intro/","title":"Brief Introduction to DeFi","text":""},{"location":"DeFin/Intro/#overview","title":"Overview","text":"<p>Decentralized finance, or DeFi, has emerged as a promising alternative to traditional finance in recent years. Built on the principles of open, permissionless, and highly interoperable protocol stacks, DeFi has the potential to revolutionize the way we think about financial services. </p>"},{"location":"DeFin/Intro/#cefi-vs-defi","title":"CeFi vs. DeFi","text":"<p>The centralized finance system has three main characteristics: it holds custodies of customers' funds, it intermediates for transactions, and it lacks privacy. DeFi, on the other hand, is built on decentralized smart contract platforms and is permissionless, non-custodial, and decentralized trust-based. In terms of privacy, DeFi offers pseudonymity, as balances, transactions, and timestamps are all public, but real identities are not disclosed.</p> <p></p>"},{"location":"DeFin/Intro/#advantages","title":"Advantages","text":"<p>Efficiency and transparency are two major advantages of DeFi. DeFi protocols enable transactions to be executed automatically through smart contracts, without the need for intermediaries. This reduces transaction costs, increases efficiency, and enables faster settlement times. Additionally, DeFi protocols are transparent, as anyone can inspect the smart contract code and verify the execution and state of the system.</p>"},{"location":"DeFin/Intro/#stack-layer","title":"Stack &amp; Layer","text":"<p>The DeFi stack consists of 5 main roles: users, protocols, keepers, oracles, and bridges. </p> <p>Users are the individuals who interact with the DeFi protocols, while protocols are the sets of rules and smart contracts that define how those interactions take place. Keepers are automated agents that maintain the state of the system, while oracles provide external data to the protocols. Finally, bridges are the mechanisms that enable DeFi protocols to interact with each other and with external systems.</p> <p>DeFi can be divided into 5 layers based on their functionality and purpose:</p> <ul> <li> <p>Settlement layer - this layer consists of the underlying blockchain technology that supports DeFi applications and infrastructure.</p> </li> <li> <p>Asset Layer - this layer refers to the creation, distribution, and management of digital assets such as cryptocurrencies and tokenized assets. It enables the issuance and transfer of assets on a decentralized network, allowing for greater liquidity and accessibility of financial assets.</p> </li> <li> <p>Protocol layer - this layer consists of the decentralized protocols and smart contracts that provide the underlying functionality for different DeFi applications, such as decentralized exchanges, lending platforms, and asset management protocols.</p> </li> <li> <p>Application layer - this layer consists of the end-user-facing DeFi applications that utilize the underlying protocols and infrastructure to provide specific financial services, such as trading, lending, or investing.</p> </li> <li> <p>Aggregation layer - this layer includes the various services that support DeFi applications and users, such as wallets, market data providers, and analytics tools.</p> </li> </ul> <p></p>"},{"location":"DeFin/Intro/#services","title":"Services","text":"<p>DeFi offers a wide range of services, including decentralized exchanges, decentralized lending and so on.</p> <p>Decentralized exchanges allow users to trade cryptocurrencies without the need for a central authority or intermediary, providing greater transparency and autonomy. Decentralized lending enables users to lend and borrow assets within one transaction, without the need for a credit score or centralized financial institution. People can use decentralized lending, such as flash loans, to engage in arbitrage and make profits.</p> <p></p>"},{"location":"DeFin/Intro/#risks","title":"Risks","text":"<p>Like any emerging technology, DeFi is not without risks. Security risks, such as network attacks, consensus attacks, and smart contract bugs, can lead to financial losses. Additionally, there are systematic risks associated with DeFi, such as liquidation problem, price declines, and high transaction fees. It is important for users to be aware of these risks and to take appropriate measures to mitigate them.</p>"},{"location":"DeFin/Intro/#open-research-challenges","title":"Open Research Challenges","text":"<p>There are several open research challenges in DeFi, including program and protocol analysis and verification, incentive design, and the interaction between CeFi and DeFi. As DeFi continues to grow and evolve, addressing these challenges will be crucial to its continued success.</p>"},{"location":"DeFin/Intro/#conclusion","title":"Conclusion","text":"<p>In summary, DeFi is a transformative development that enables greater accessibility, transparency, and autonomy in the financial sector. DeFi applications are faster, cheaper, and more secure than traditional finance by utilizing decentralized networks and smart contracts. </p> <p>However, there are also risks associated with DeFi, including security vulnerabilities, systemic risk, and the lack of regulatory oversight. As DeFi continues to evolve, it will be crucial to address these risks and ensure that its benefits can be enjoyed by a wider audience.</p>"},{"location":"ZK/Intro/","title":"Brief Introduction to Zero Knowledge","text":""},{"location":"ZK/Intro/#interactive-proof","title":"Interactive Proof","text":"<p>Zero-knowledge proofs (ZKP) are a powerful cryptographic tool that allow one party (the prover) to convince another party (the verifier) that a statement is true, without revealing any additional information beyond the statement's validity.</p> <p>To understand zkp, it's helpful to first consider interactive proofs, involving interaction between the prover and verifier. We only consider efficiently verifiable proofs, a type of interactive proof using a verification string to confirm the validity of a statement. The verification string  \\(w = poly(|x|)\\), and the  verification time \\(t =poly(|x|)\\).</p> <p></p> <p>ZKP is applied to NP languages, which are those that can be verified in polynomial time. The verifier must be able to confirm the truthfulness of a statement and reject false statements. This is known as completeness and soundness, respectively:</p> <ul> <li>\\(\\forall x  \\in L,\\exists w ,V(x,w) = 1\\)</li> <li>\\(\\forall x  \\notin L,\\forall  w ,V(x,w) = 0\\)</li> </ul> <p>Interactive proof involves two additional ingredients: randomness and interaction:</p> <ul> <li> <p>Randomness: Verifier is randomized, and the verifier can also have an error with negligible probability   $$   Pr[(P,V)(x) = accept] \\leq negl(\\lambda)   $$</p> </li> <li> <p>Interaction: Prover interact with the verifier.</p> </li> </ul> <p>This class of language which has an interactive proof is called IP language.</p>"},{"location":"ZK/Intro/#zero-knowledge","title":"Zero Knowledge","text":"<p>The goal of zkp is to allow the verifier to gain no knowledge beyond the validity of the statement being proven. After the interactive proof, the verifier can only obtain the true value and the view of the interactions: $$ View = (q_{1},a_{1},q_{2},a_{2},...) $$ The simulation paradigm allows the verifier to simulate a view, which is indistinguishable from the real view. This is achieved through computational indistinguishability, where two distributions are considered indistinguishable if they can only be differentiated with negligible probability \\(negl(\\lambda)\\).</p> <p>We write it formally as follows: $$ View(P,V)(x) \\approx Sim(x,1^{\\lambda}) $$ There are different flavors of zkp, such as computational indistinguishable, perfect identical, and statistical close distribution zkp. These are distinguished based on the degree of similarity between the simulated and real views.</p>"},{"location":"ZK/Intro/#application","title":"Application","text":"<p>Zkp has practical applications in proving properties about messages without revealing the message itself, or in computing a function of two parties' inputs without disclosing their inputs to each other (secure 2-party computation).</p> <p></p>"},{"location":"ZK/Intro/#complexity-theory","title":"Complexity Theory","text":"<p>In complexity theory, zkp is considered the randomized analogue to the NP class. </p> No Randomization With Randomizations Efficiently Solvable P (Polynomial time) BPP (Bounded-error Probabilistic Polynomial time) Efficiently Verifiable NP (Non-deterministic Polynomial time) IP (Interactive Polynomial time) <p>Computer scientist has proved that IP is greater than NP. Furthermore, we can use Arthur-Merlin game to simplify ZKP, in which the verifier only need to compute a decision function. We can also use Fiat-Shamir paradigm removes the need for interaction in the verification process.</p>"}]}